
%{
    #include <iostream>
    using namespace std;
    int yylex();
    void yyerror(const char*);
    #include "hw3_output.hpp"
    #include "output.hpp"
    extern int yylineno;
    using namespace output;
    int loopDepth = 0;
    #include "source.hpp"
    #include "CheckFunctions.h"
    TablesStack* tableStack=new TablesStack;
    offsetStack* offsettStack=new offsetStack;
    #define YYERROR_VERBOSE 1 
    /* //for tests:  #define YYDEBUG 1 */
    string global_exp_type = "";
    ExpNode* global_Exp = nullptr;
    string global_label="";
    #include "cg.hpp"
    #include "helper.hpp"
    #include <stack>
    stack<ExpNode*> globalExpStack;

%}



%nonassoc INT BYTE B BOOL  TRUE FALSE RETURN IF  WHILE BREAK CONTINUE SC LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left  equality
%left  relational
%left  additive
%left  multiplicative
%right NOT
%left LPAREN
%left RPAREN
%right ELSE
%token COMMA


%%




Program: M1 Statements 
       {
         checkMainFunction(*tableStack);

         printProductionRule(1);
       }
       ;

M1: %empty
  {
    //createNewScope(*tableStack);  // Create global scope //check
    //offsettStack->push_offset(0);  // Initialize offset stack for global scope // check

    vector<string> printParmType = {"string"};
    addFunctionToGlobalScope(*tableStack, "print", "void", printParmType);
    
    vector<string> printiParmType = {"int"};
    addFunctionToGlobalScope(*tableStack, "printi", "void", printiParmType);
    
    vector<string> readiParmType = {"int"};  
    addFunctionToGlobalScope(*tableStack, "readi", "int", readiParmType);
  }
  ;

//////////////////////////////////////////////////////////////////////////////////

Statements: Statement { printProductionRule(2);
                        // Debug: Ensure no type checks are done here directly.
              //for tests: cout << "Reducing Statements -> Statements Statement at line " << yylineno << endl; 
              } ///////delete }
          | Statements Statement { printProductionRule(3);
                        // Debug: Ensure no type checks are done here directly.
              //for tests: cout << "Reducing Statements -> Statements Statement at line " << yylineno << endl; 
              } ///////delete

          ;

Statement: LBRACE M_NEW_SCOPE Statements RBRACE 
         {
           printProductionRule(4);
           exitScope(*tableStack);
           offsettStack->pop_offset(yylineno);
         }
         | Type ID SC 
         {
           string varName = static_cast<IdentifierStr*>($2)->id;
           string varType = static_cast<TNode*>($1)->type;
           string llvmType = getLLVMType(varType);
           string llvmVarName = "%" + varName;
           CodeBuffer::instance().emit(llvmVarName + " = alloca " + llvmType);
           
           // Initialize with default value
           if (varType == "bool") {
             CodeBuffer::instance().emit("store i1 false, i1* " + llvmVarName);
           } else if (varType == "int" || varType == "byte") {
             CodeBuffer::instance().emit("store " + llvmType + " 0, " + llvmType + "* " + llvmVarName);
           }
           
           checkVariableDeclaration(*tableStack, static_cast<IdentifierStr*>($2)->id, yylineno);
           addSymbolToCurrentScope(*tableStack, varName, varType, offsettStack->top_offset(yylineno));
           offsettStack->update_top_offset();
           delete static_cast<IdentifierStr*>($2);
           delete static_cast<TNode*>($1);
           printProductionRule(5);
         }
         | Type ID ASSIGN Exp SC
         {
           string varName = static_cast<IdentifierStr*>($2)->id;
           string varType = static_cast<TNode*>($1)->type;
           string expType = $4->type;
           checkVariableDeclaration(*tableStack, varName, yylineno);
           checkAssignment(varType, expType, yylineno);
           string llvmType = getLLVMType(varType);
           string llvmVarName = "%" + varName;           
           CodeBuffer::instance().emit(llvmVarName + " = alloca " + llvmType);
           
           CodeBuffer::instance().emit("store " + llvmType + " " + $4->llvm_var + ", " + llvmType + "* " + llvmVarName);
           addSymbolToCurrentScope(*tableStack, varName, varType, offsettStack->top_offset(yylineno));
           offsettStack->update_top_offset();
           delete static_cast<IdentifierStr*>($2);
           delete static_cast<TNode*>($1);
           delete $4;
           printProductionRule(6);
         }
         | ID ASSIGN Exp SC
         {
           string varName = static_cast<IdentifierStr*>($1)->id;
           string varType = getSymbolType(*tableStack, varName);
           if (varType.empty()) {
             output::errorUndef(yylineno, varName);
             exit(0);
           }
           checkAssignment(varType, $3->type, yylineno); //check12
           string llvmType = getLLVMType(varType);
           string llvmVarName = "%" + varName;
           CodeBuffer::instance().emit("store " + llvmType + " " + $3->llvm_var + ", " + llvmType + "* " + llvmVarName);
           delete static_cast<IdentifierStr*>($1);
           delete $3;
           printProductionRule(7);
         }
         | Call SC { printProductionRule(8); }
         | RETURN SC 
         {
           checkReturnStatement(*tableStack, "void", yylineno);
           printProductionRule(9);
         }
         | IF LPAREN Exp RPAREN M_CHECK_IF_BOOL_andAddTrueLabel M_NEW_SCOPE Statement CLOSE_SCOPE
         {
           ExpNode* globalExp = globalExpStack.top();
           globalExpStack.pop();
           if(globalExp != $3) cout << "error in global exp stack" << endl;
           
           // Emit branch to next label (end of if statement)
           CodeBuffer::instance().emit("br label %" + static_cast<ExpNode*>($3)->next_label);
           
           // Emit false label
           CodeBuffer::instance().emit(static_cast<ExpNode*>($3)->false_label + ":");
           
           // Emit next label (end of if statement)
           CodeBuffer::instance().emit(static_cast<ExpNode*>($3)->next_label + ":");
           
           printProductionRule(10);
           delete $3;
         }
         | IF LPAREN Exp RPAREN M_CHECK_IF_BOOL_andAddTrueLabel M_NEW_SCOPE Statement CLOSE_SCOPE ELSE M_NEW_SCOPE M_ADD_FALSE_LABEL Statement CLOSE_SCOPE
         {
           ExpNode* globalExp = globalExpStack.top();
           globalExpStack.pop();
           if(globalExp != $3) cout << "error in global exp stack" << endl;
           
           // Emit branch to next label (end of if-else statement)
           CodeBuffer::instance().emit("br label %" + static_cast<ExpNode*>($3)->next_label);
           
           // Emit next label (end of if-else statement)
           CodeBuffer::instance().emit(static_cast<ExpNode*>($3)->next_label + ":");
           
           printProductionRule(11);
           delete $3;
         
         }
         | WHILE LPAREN Exp RPAREN M_CHECK_WHILE_BOOL M_NEW_SCOPE_LOOP M_ADD_WHILE_TRUE_LABEL Statement M_ADD_WHILE_END
         {
           ExpNode* globalExp = globalExpStack.top();
           globalExpStack.pop();
           if(globalExp != $3) cout << "errrrrror ya m3alem" << endl;
           
           exitScope(*tableStack);
           offsettStack->pop_offset(yylineno);
           loopDepth--;
           printProductionRule(12);
           delete $3;
         }
         ;
         | BREAK SC
         {
           checkBreakStatement(loopDepth, yylineno);
           ExpNode* globalExp = globalExpStack.top();
           CodeBuffer::instance().emit("br label %" + globalExp->false_label);
           printProductionRule(13);
         }
         ;

          | CONTINUE SC
         {
           checkContinueStatement(loopDepth, yylineno);
           ExpNode* globalExp = globalExpStack.top();
           CodeBuffer::instance().emit("br label %" + globalExp->next_label); //check12
           printProductionRule(14);
         }
         ;

M_CHECK_WHILE_BOOL: %empty
                  {
                    if (!isBooleanType(global_exp_type)) {
                     output::errorMismatch(yylineno);
                     exit(0);
                    }
                    string conditionLabel = CodeBuffer::instance().freshLabel();
                    CodeBuffer::instance().emit(conditionLabel + ":");
                    globalExpStack.push(global_Exp);
                    
                    // Emit the conditional branch
                    CodeBuffer::instance().emit("br i1 " + global_Exp->llvm_var + ", label %" + global_Exp->true_label + ", label %" + global_Exp->false_label);//check12
                  }
                  ;

M_ADD_WHILE_TRUE_LABEL: %empty
                      {
                        ExpNode* globalExp = globalExpStack.top();
                        CodeBuffer::instance().emit(globalExp->true_label + ":");
                      }
                      ;

M_ADD_WHILE_END: %empty
               {
                 ExpNode* globalExp = globalExpStack.top();
                 
                 // Emit jump back to the condition check
                 string conditionLabel = CodeBuffer::instance().freshLabel();
                 CodeBuffer::instance().emit("br label %" + conditionLabel);
                 
                 // Emit the loop exit label (false label)
                 CodeBuffer::instance().emit(globalExp->false_label + ":");
                 
                 // Create a new label for the code after the loop
                 string afterLoopLabel = CodeBuffer::instance().freshLabel();
                 CodeBuffer::instance().emit(afterLoopLabel + ":");
                 
                 // Update the ExpNode with the new labels
                 globalExp->next_label = afterLoopLabel;
               //  globalExp->continue_label = conditionLabel; //check12
                 
                 // You might want to store these labels in a structure for nested loops
                 // if you need to handle break and continue for multiple loop levels
               }
               ;

CLOSE_SCOPE: %empty
           {
             exitScope(*tableStack);
             offsettStack->pop_offset(yylineno);
             if (!globalExpStack.empty()) {
               ExpNode* globalExp = globalExpStack.top();
               CodeBuffer::instance().emit("br label %" + globalExp->next_label);
             }
           };


M_NEW_SCOPE: %empty
           {
             createNewScope(*tableStack);
             offsettStack->push_offset(offsettStack->top_offset(yylineno));
           }
           ;


M_NEW_SCOPE_LOOP: %empty
                {
                  createNewScope(*tableStack);
                  offsettStack->push_offset(offsettStack->top_offset(yylineno));
                  loopDepth++;
                }
                ;
M_CHECK_IF_BOOL_andAddTrueLabel: %empty
                {
                  if (!isBooleanType(global_exp_type)) {
                   output::errorMismatch(yylineno);
                   exit(0);
                  }
                  // Emit the conditional branch
                  CodeBuffer::instance().emit("br i1 " + global_Exp->llvm_var + ", label %" + global_Exp->true_label + ", label %" + global_Exp->false_label);
                  
                  // Emit the true label
                  CodeBuffer::instance().emit(global_Exp->true_label + ":");
                  
                  globalExpStack.push(global_Exp);
                };

M_ADD_FALSE_LABEL: %empty
                 {
                   ExpNode* globalExp = globalExpStack.top();
                   
                   // Emit branch to next label (end of if-else statement)
                   CodeBuffer::instance().emit("br label %" + globalExp->next_label);
                   
                   // Emit the false label (start of else block)
                   CodeBuffer::instance().emit(globalExp->false_label + ":");
                 };
//////////////////////////////////////////////////////////////////////////////////

Call: ID LPAREN Exp RPAREN
    {
      string funcName = static_cast<IdentifierStr*>($1)->id;
      string argType = $3->type;  // This will be "int" in your example
      vector<string> argTypes = {argType};
      // changing checkFunctionCall
      // $$ = checkFunctionCall(*tableStack, funcName, argTypes, yylineno);
      functions* func = checkFunctionCall(*tableStack, funcName, argTypes, yylineno);
      /*
      // Check if the function exists
      tableEntry* entry = nullptr;
      for (const auto& e : tableStack->ParentScope->scope) {
        if (e->name == funcName) {
          entry = e;
          break;
        }
      }
      
      if (!entry) {
        output::errorUndefFunc(yylineno, funcName);
        exit(0);
      }
    //  cout<<"entry->type is : "<<entry->type<<endl;////////delete
      // Check if the entry is a function
      if (entry->type != "function") {
        output::errorUndefFunc(yylineno, funcName);
        exit(0);
      }

      // Now we know it's a function, we can safely cast it
       functions* func = dynamic_cast<functions*>(entry);
    if (!func) {
        //for tests: cout<<"debug line 212 parser.ypp"<<endl;/////delete
        output::errorUndefFunc(yylineno, funcName);
        exit(0);
    }

    */

      /*
      bool matchFound = false;
        for (const auto& paramType : func->all_arg) {
            if (isTypeCompatible(paramType, $3->type)) {
                matchFound = true;
                break;
            }
        }

        if (!matchFound) {
            output::errorPrototypeMismatch(yylineno, funcName, output::makeFunctionType(func->all_arg[0], func->ret_type));
            exit(0);
        }
      */
     if (!isTypeCompatible(func->all_arg[0], $3->type)) {
    output::errorPrototypeMismatch(yylineno, funcName, output::makeFunctionType(func->all_arg[0], func->ret_type));
    exit(0);
}

      string resultVar;
      string callInstr;
      if (func->ret_type == "void") {
          callInstr = "call void @" + funcName + "(" + getLLVMType(argType) + " " + $3->llvm_var + ")";
      } else {
          resultVar = freshVar();
          callInstr = resultVar + " = call " + getLLVMType(func->ret_type) + " @" + funcName + "(" + getLLVMType(argType) + " " + $3->llvm_var + ")";
      }
      CodeBuffer::instance().emit(callInstr);
      $$ = new ExpNode(func->ret_type, func->ret_type == "void" ? "" : resultVar);
     // cout<<$$->type<<endl; /////////////////////delete
      printProductionRule(15);
      
      delete static_cast<IdentifierStr*>($1);
      delete $3;
    }
  ;


Type: INT { $$=new TNode("int"); printProductionRule(16); }
    | BYTE { $$=new TNode("byte"); printProductionRule(17); }
    | BOOL { $$=new TNode("bool"); printProductionRule(18); };


Exp: LPAREN Exp RPAREN { $$ = $2; printProductionRule(19); global_exp_type=$$->type; global_Exp=dynamic_cast<ExpNode*>($$);}
   | Exp additive Exp 
     { 
       checkNumericExpression($1, *tableStack);
       checkNumericExpression($3, *tableStack);
      // string type1 = $1->type;
      // string type2 = $3->type;
      //for tests: cout << type1 <<endl;
      // $$ = new ExpNode(type1 == "int" || type2 == "int" ? "int" : "byte");
       printProductionRule(20);
      
       if(static_cast<Binop*>($2)->op=="+"){
        $$=emitArithmetic("add",dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
       }

       if(static_cast<Binop*>($2)->op=="-"){
        $$=emitArithmetic("sub",dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
       }

       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);

     }
   | Exp multiplicative Exp 
     { 
       checkNumericExpression($1, *tableStack);
       checkNumericExpression($3, *tableStack);
      // string type1 = $1->type;
      // string type2 = $3->type;
      // $$ = new ExpNode(type1 == "int" || type2 == "int" ? "int" : "byte");
       printProductionRule(20);

      //  if(static_cast<Binop*>($2)->op=="*"){
      //   $$=emitArithmetic("mul",dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
      //  }
       
      //  if(static_cast<Binop*>($2)->op=="/"){
      //   $$=emitDivision(dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
      //  }
      if(static_cast<Binop*>($2)->op=="/"){
        $$ = emitDivision(dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
      } else if(static_cast<Binop*>($2)->op=="*"){
        $$ = emitArithmetic("mul",dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
      }

       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | ID 
     { 
       string varName = static_cast<IdentifierStr*>($1)->id;
       string varType = getSymbolType(*tableStack, varName);
       
       if(varType.empty() || varType=="function") {
         output::errorUndef(yylineno, varName);
         exit(0);
       }
       string llvmType = getLLVMType(varType);
       string llvmVarName = "%" + varName;
       string resultVar = freshVar();
       
       // Emit LLVM IR for loading variable value
       CodeBuffer::instance().emit(resultVar + " = load " + llvmType + ", " + llvmType + "* " + llvmVarName);
       $$ = new ExpNode(varType,resultVar); //check12
       
       printProductionRule(21);
       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | Call { $$ = $1; printProductionRule(22);global_exp_type=$$->type;global_Exp=dynamic_cast<ExpNode*>($$);}
   | NUM { $$ = new ExpNode("int"); printProductionRule(23);global_exp_type=$$->type;global_Exp=dynamic_cast<ExpNode*>($$);}
   | NUM B 
     { 
       int value = static_cast<Num*>($1)->num;
       if(!isLegalByteValue(value)) {
         output::errorByteTooLarge(yylineno, to_string(value));
         exit(0);
       }
       $$ = new ExpNode("byte");
       printProductionRule(24);
       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | STRING { $$ = new ExpNode("string");printProductionRule(25); global_exp_type=$$->type;global_Exp=dynamic_cast<ExpNode*>($$);}
   | TRUE { $$ = new ExpNode("bool", "true"); global_exp_type=$$->type;global_Exp=dynamic_cast<ExpNode*>($$);}
   | FALSE { $$ = new ExpNode("bool", "false"); global_exp_type=$$->type;global_Exp=dynamic_cast<ExpNode*>($$);}
   | NOT Exp 
     { 
       checkBooleanExpression($2, *tableStack);
       $$ = emitBooleanNot(static_cast<ExpNode*>($2));
       printProductionRule(28);
       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | Exp AND Exp 
  { 
    checkBooleanExpression($1, *tableStack);
    checkBooleanExpression($3, *tableStack);
    emitBooleanAnd(dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
    $$ = new ExpNode("bool");
    static_cast<ExpNode*>($$)->true_label = static_cast<ExpNode*>($3)->true_label;
    static_cast<ExpNode*>($$)->false_label = static_cast<ExpNode*>($1)->false_label;
    printProductionRule(29);
    global_exp_type = $$->type;
    global_Exp = dynamic_cast<ExpNode*>($$);
  }
| Exp OR Exp 
  { 
    checkBooleanExpression($1, *tableStack);
    checkBooleanExpression($3, *tableStack);
    emitBooleanOr(dynamic_cast<ExpNode*>($1), dynamic_cast<ExpNode*>($3));
    $$ = new ExpNode("bool");
    static_cast<ExpNode*>($$)->true_label = static_cast<ExpNode*>($1)->true_label;
    static_cast<ExpNode*>($$)->false_label = static_cast<ExpNode*>($3)->false_label;
    printProductionRule(30);
    global_exp_type = $$->type;
    global_Exp = dynamic_cast<ExpNode*>($$);
  }
   | Exp equality Exp 
     { 
       checkTypeMismatch($1->type, $3->type, "equality", yylineno);
       $$ = emitRelop(static_cast<Relop*>($2)->op, static_cast<ExpNode*>($1),static_cast<ExpNode*>($3));
       printProductionRule(31);
       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | Exp relational Exp 
     { 
       checkNumericExpression($1, *tableStack);
       checkNumericExpression($3, *tableStack);
       $$ = emitRelop(static_cast<Relop*>($2)->op, static_cast<ExpNode*>($1),static_cast<ExpNode*>($3));
       printProductionRule(31);
       global_exp_type=$$->type;
       global_Exp=dynamic_cast<ExpNode*>($$);
     }
   | LPAREN Type RPAREN Exp 
     { 
    string targetType = static_cast<TNode*>($2)->type;
    string sourceType = $4->type;
    string llvmTargetType = getLLVMType(targetType);
    string llvmSourceType = getLLVMType(sourceType);
    
    if (targetType != "int" && targetType != "byte") {
      output::errorMismatch(yylineno);
      exit(0);
    }
    if (!isTypeCompatible(targetType, sourceType, true)) {
      output::errorMismatch(yylineno);
      exit(0);
    }
    
    string resultVar = freshVar();
    if (targetType == "int" && sourceType == "byte") {
      CodeBuffer::instance().emit(resultVar + " = zext i8 " + $4->llvm_var + " to i32");
    } else if (targetType == "byte" && sourceType == "int") {
      CodeBuffer::instance().emit(resultVar + " = trunc i32 " + $4->llvm_var + " to i8");
    } else {
      resultVar = $4->llvm_var; // No conversion needed
    }
    
    $$ = new ExpNode(targetType, resultVar);
    printProductionRule(32);
    global_exp_type = $$->type;
    global_Exp = dynamic_cast<ExpNode*>($$);
     }
   ;
    // Exp: LPAREN Exp RPAREN{printProductionRule(19);}
    //     |Exp additive Exp{printProductionRule(20);}
    //     |Exp multiplicative Exp{printProductionRule(20);}
    //     |ID{printProductionRule(21);}
    //     |Call{printProductionRule(22);}
    //     |NUM{printProductionRule(23);}
    //     |NUM B{printProductionRule(24);}
    //     |STRING{printProductionRule(25);}
    //     |TRUE{printProductionRule(26);}
    //     |FALSE{printProductionRule(27);}
    //     |NOT Exp{printProductionRule(28);}
    //     |Exp AND Exp{printProductionRule(29);}
    //     |Exp OR Exp{printProductionRule(30);}
    //     |Exp equality Exp{printProductionRule(31);}
    //     |Exp relational Exp{printProductionRule(31);}
    //     |LPAREN Type RPAREN Exp{printProductionRule(32);};


%%

void initBuiltInFunctions() {
    CodeBuffer::instance().emitGlobal("@.str_specifier = private unnamed_addr constant [4 x i8] c\"%s\\0A\\00\", align 1");
    CodeBuffer::instance().emitGlobal("@.int_specifier = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\", align 1");
    CodeBuffer::instance().emitGlobal("@.int_specifier_scan = private unnamed_addr constant [3 x i8] c\"%d\\00\", align 1");

    // print function
    CodeBuffer::instance().emitGlobal("define void @print(i8*) {");
    CodeBuffer::instance().emitGlobal("  %spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
    CodeBuffer::instance().emitGlobal("  call i32 (i8*, ...) @printf(i8* %spec_ptr, i8* %0)");
    CodeBuffer::instance().emitGlobal("  ret void");
    CodeBuffer::instance().emitGlobal("}");

    // printi function
    CodeBuffer::instance().emitGlobal("define void @printi(i32) {");
    CodeBuffer::instance().emitGlobal("  %spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
    CodeBuffer::instance().emitGlobal("  call i32 (i8*, ...) @printf(i8* %spec_ptr, i32 %0)");
    CodeBuffer::instance().emitGlobal("  ret void");
    CodeBuffer::instance().emitGlobal("}");

    // readi function
    CodeBuffer::instance().emitGlobal("define i32 @readi() {");
    CodeBuffer::instance().emitGlobal("  %spec_ptr = getelementptr [3 x i8], [3 x i8]* @.int_specifier_scan, i32 0, i32 0");
    CodeBuffer::instance().emitGlobal("  %num = alloca i32");
    CodeBuffer::instance().emitGlobal("  call i32 (i8*, ...) @scanf(i8* %spec_ptr, i32* %num)");
    CodeBuffer::instance().emitGlobal("  %result = load i32, i32* %num");
    CodeBuffer::instance().emitGlobal("  ret i32 %result");
    CodeBuffer::instance().emitGlobal("}");
}

int main(){
    // yydebug = 1; 
    CodeBuffer::instance().emit("define i32 @main(){");
    CodeBuffer::instance().emitGlobal("declare i32 @printf(i8*, ...)");
    CodeBuffer::instance().emitGlobal("declare void @exit(i32)");
    CodeBuffer::instance().emitGlobal("declare i32 @scanf(i8*, ...)");
    CodeBuffer::instance().emitGlobal("@.str_zeroDiv = internal constant [23 x i8] c\"Error division by zero\\00\"");

    // defining the built in functions 
    initBuiltInFunctions();

    // yyparse
    yyparse();
    // yyparse

    exitScope(*tableStack);

    CodeBuffer::instance().emit("ret i32 0");
    CodeBuffer::instance().emit("}");

    CodeBuffer::instance().printGlobalBuffer();
    CodeBuffer::instance().printCodeBuffer();
    
    return 0;

}

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}